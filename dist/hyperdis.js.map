{"version":3,"sources":["webpack://hyperdis/webpack/universalModuleDefinition","webpack://hyperdis/webpack/bootstrap","webpack://hyperdis/./src/utils/set.js","webpack://hyperdis/./src/utils/index.js","webpack://hyperdis/./src/graph-node.js","webpack://hyperdis/./src/electric-node.js","webpack://hyperdis/./src/graph.js","webpack://hyperdis/./src/model.js","webpack://hyperdis/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","makeEntry","arr","sCon","forEach","elem","undefined","ForeignSet","_classCallCheck","this","_set","keys","set1","set2","filteredKeys","s1","s2","push","isSimpleObject","obj","_typeof","toString","constructor","match","win","reqAnimFrame","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","callback","setTimeout","getTimeBasedId","__lastTime","Date","getTime","__id","flat","_len","arguments","length","params","Array","_key","res","param","apply","_toConsumableArray","scheduler","onFinishCallback","queue","animationFrame","listeners","fns","reduce","store","fn","map","unique","fetch","namedNode","_len2","_key2","node","qualifiedName","seed","fetchAggregator","_len3","_key3","dependencies","slice","getUpstreamNodes","list","rec","qname","placedIndex","preArr","postArr","concat","outgoingEdges","resolver","accumulate","_len4","_key4","resp","nodeDetails","assign","_defineProperty","identity","CustomResolver","utils_classCallCheck","dep","_dep","GraphNode","options","graph_node_classCallCheck","edges","_seed","requireResolve","retriever","history","electricEdges","_edges","_this","entry","graph_node_toConsumableArray","retrieveDetails","edge","head","hist","ElectricNode","electric_node_classCallCheck","nextFrame","currentFrame","lstnrs","index","nodes","nFn","pullableRecent","filter","_this2","pullableEnd","Graph","graph_classCallCheck","qualifiedNodeMap","graph_node","_wholeSet","_propagate","propagationOverride","currentFrameListeners","nextFrameListeners","_schedule","flush","mount","val","resolveReqList","objn","perv","addDependencies","_node","graph_toConsumableArray","getDependencies","set","getResolvedList","resolve","prop","props","fnSpec","_ref","eNode","electric_node","addEdges","addElectricNode","type","changedSet","upstreamNodes","upstreamNode","append","__execUniqueElectricEdges","from","Set","_this3","cfLstnrs","nfLstnrs","difference","toArray","repeatHead","e","resetPropagationOverride","_this4","qnames","args","update","resolved","resolveDependencyOrder","resolveMap","neighbour","isRoot","model","Model","model_classCallCheck","_graph","graph","_lockFlag","_reqQ","mountPoint","_addPropInModel","_customResolver","calculationConfig","customResolver","varName","fetchFn","model_toConsumableArray","model_defineProperty","createNodesFrom","instantCall","_graph$stopPropagatio","propsArr","unsub","createElectricNodeOf","stopPropagation","setPropagationOverride","resetNodeValue","_graph$stopPropagatio2","setProp","len","getNodeValue","getNodeFromQualifiedName","__webpack_exports__"],"mappings":"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","file":"hyperdis.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hyperdis\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hyperdis\"] = factory();\n\telse\n\t\troot[\"hyperdis\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const makeEntry = (arr, sCon) => {\n    arr.forEach((elem) => {\n        if (elem === undefined || elem === null) {\n            return;\n        }\n        sCon[elem] = 1;\n    });\n};\n\nexport default class ForeignSet {\n    constructor (arr) {\n        this._set = {};\n        makeEntry(arr, this._set);\n    }\n\n    append (arr) {\n        makeEntry(arr, this._set);\n        return this;\n    }\n\n    toArray () {\n        return Object.keys(this._set);\n    }\n\n    static difference (set1, set2) {\n        let key;\n        const filteredKeys = [],\n            s1 = set1._set,\n            s2 = set2._set;\n        for (key in s1) {\n            if (!({}).hasOwnProperty.call(s1, key)) {\n                continue;\n            }\n            if (key in s2) {\n                continue;\n            }\n            filteredKeys.push(key);\n        }\n        return new ForeignSet(filteredKeys);\n    }\n}\n","/* global window */\n\nimport ForeignSet from './set';\n\nconst\n    isSimpleObject = (obj) => {\n        let token;\n        if (typeof obj === 'object') {\n            if (obj === null) { return false; }\n            token = Object.prototype.toString.call(obj);\n            if (token === '[object Object]') {\n                return (obj.constructor.toString().match(/^function (.*)\\(\\)/m) || [])[1] === 'Object';\n            }\n        }\n        return false;\n    },\n    minMsThreshold = 16,\n    /* istanbul ignore next */win = typeof window === 'undefined' ? (this || {}) : window,\n    /* istanbul ignore next */ reqAnimFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame ||\n        win.mozRequestAnimationFrame || win.oRequestAnimationFrame ||\n        win.msRequestAnimationFrame ||\n        function (callback) {\n            setTimeout(callback, minMsThreshold);\n        },\n\n    getTimeBasedId = () => {\n        if (getTimeBasedId.__lastTime === new Date().getTime()) {\n            return (getTimeBasedId.__lastTime).toString() + (getTimeBasedId.__id++).toString();\n        }\n\n        getTimeBasedId.__id = 0;\n        getTimeBasedId.__lastTime = new Date().getTime();\n        return (getTimeBasedId.__lastTime).toString() + (getTimeBasedId.__id++).toString();\n    },\n    pullableRecent = (nodes, fn) => {\n        let nFn = () => {\n            fn(...nodes.map((node) => {\n                const\n                    hist = node.history,\n                    l = hist.length - 1;\n                return [hist[l - 1 < 0 ? 0 : l - 1], hist[l]];\n            }));\n        };\n        nFn.__id = getTimeBasedId();\n        return nFn;\n    },\n    pullableEnd = (nodes, fn) => {\n        let nFn = () => {\n            fn(...nodes.map((node) => {\n                const hist = node.history;\n                return [hist[0], hist[hist.length - 1]];\n            }));\n        };\n        nFn.__id = getTimeBasedId();\n        return nFn;\n    },\n    unique = fns => fns\n                    .reduce((store, fn) => {\n                // @warn function with side effect, it mutates the store passed during initialization\n                        if (fn.__id in store.map) {\n                            return store;\n                        }\n\n                        store.map[fn.__id] = 1;\n                        store.unique.push(fn);\n\n                        return store;\n                    }, { map: {}, unique: [] })\n                    .unique,\n    compose = fns => () => {\n        fns.forEach(fn => fn());\n    },\n    flat = (...params) => {\n        const res = [];\n        params.forEach(param => res.push(...param));\n        return res;\n    },\n    identityMap = arrays => arrays,\n    splitPathProp = (path) => {\n        const pathArr = path.split('.'),\n            len = pathArr.length;\n        return [pathArr.slice(0, len - 1), pathArr[len - 1]];\n    },\n    scheduler = (onFinishCallback) => {\n        let queue = [],\n            animationFrame = null;\n\n        onFinishCallback = onFinishCallback &&\n            typeof onFinishCallback === 'function' && onFinishCallback || (() => { });\n\n        return (listeners) => {\n            [].push.apply(queue, listeners);\n            if (animationFrame === null) {\n                animationFrame = reqAnimFrame(() => {\n                    unique(queue).forEach(fn => fn());\n                    onFinishCallback();\n                    animationFrame = null;\n                    queue.length = 0;\n                });\n            }\n        };\n    },\n    fetch = namedNode => (...params) => params.map((param) => {\n        const node = namedNode[param];\n        return {\n            name: node.name,\n            qualifiedName: node.qualifiedName,\n            value: node.seed\n        };\n    }),\n    fetchAggregator = (...params) => ({\n        dependencies: params.slice(0, params.length - 1),\n        fn: params[params.length - 1]\n    }),\n    getUpstreamNodes = (list) => {\n        let res = [];\n        const map = {};\n        list.forEach(node => map[node.qualifiedName] = -1);\n        function rec (arr) {\n            arr.forEach((node) => {\n                let qname,\n                    placedIndex,\n                    preArr,\n                    postArr;\n                if (!((qname = node.qualifiedName) in map)) {\n                    map[qname] = res.push(node) - 1;\n                } else {\n                    placedIndex = map[qname];\n                    if (placedIndex !== -1 && placedIndex !== res.length - 1) {\n                        // If not the last element, readjust the array so that the later dependency position is saved\n                        preArr = res.slice(0, placedIndex);\n                        postArr = res.slice(placedIndex + 1);\n                        res = preArr.concat(postArr);\n\n                        // reset the index in map\n                        postArr.forEach((elem, i) => map[elem.qualifiedName] = i + preArr.length);\n                        map[qname] = res.push(node) - 1;\n                    }\n                }\n                rec(node.outgoingEdges);\n            });\n        }\n        rec(list);\n        return res;\n    },\n    resolver = {\n        accumulate: (...params) => {\n            const resp = {};\n            params.forEach((nodeDetails) => {\n                Object.assign(resp, { [nodeDetails.name]: nodeDetails.value });\n            });\n            return resp;\n        },\n        identity: nodeDetails => nodeDetails.value\n    };\n\nfunction resolveDependencyOrder (node, resolved, resolveMap) {\n    let qname;\n    node.edges.forEach((neighbour) => {\n        resolveDependencyOrder(neighbour, resolved, resolveMap);\n    });\n\n    if (node.isRoot() || (qname = node.qualifiedName) in resolveMap) {\n        return;\n    }\n    resolved.push(node);\n    resolveMap[qname] = 1;\n}\n\n// function getUpstreamNodes (node, list) {\n//     if (node.isRoot()) {\n//         return;\n//     }\n//     node.outgoingEdges.forEach((_node) => {\n//         list.push(_node);\n//         getUpstreamNodes(_node, list);\n//     });\n// }\n\nclass CustomResolver {\n    constructor (resolver) {\n        this.fn = resolver;\n        this.dep = [];\n    }\n\n    addDependencies(...dep) {\n        this.dep.push(...dep);\n        return this;\n    }\n\n    getDependencies () {\n        return this.dep;\n    }\n\n    get () {\n        return this.fn;\n    }\n}\n\nexport {\n    isSimpleObject,\n    scheduler,\n    compose,\n    flat,\n    identityMap,\n    pullableEnd,\n    pullableRecent,\n    unique,\n    splitPathProp,\n    resolver,\n    ForeignSet,\n    resolveDependencyOrder,\n    fetch,\n    // upstreamNodes,\n    fetchAggregator,\n    CustomResolver,\n    getUpstreamNodes\n};\n","export default class GraphNode {\n    constructor (name, qualifiedName, options) {\n        /* istanbul ignore next */options = options || {};\n        this.name = name;\n        this.qualifiedName = qualifiedName;\n        this.edges = [];\n        this.outgoingEdges = [];\n        this._seed = null;\n        this.requireResolve = true;\n        this.retriever = options.retriever;\n        this.history = [];\n        this.resolver = null;\n        this.electricEdges = [];\n    }\n\n    addDependencies (...dep) {\n        this.edges.push(...dep);\n        dep.forEach(entry => entry.outgoingEdges.push(this));\n        return this;\n    }\n\n    addElectricNode (node) {\n        this.electricEdges.push(node);\n        return this;\n    }\n\n    get seed () {\n        return this._seed;\n    }\n\n    set seed (value) {\n        this._seed = value;\n        this.requireResolve = true;\n        return this;\n    }\n\n    resolve () {\n        this.seed = this.resolver(...this.retrieveDetails());\n        this.history.push(this.seed);\n        this.requireResolve = false;\n        return this;\n    }\n\n    retrieveDetails () {\n        if (this.edges.length === 0) {\n            return [{\n                name: this.name,\n                qualifiedName: this.qualifiedName,\n                value: this.seed\n            }];\n        }\n        return this.retriever(...this.edges.map(edge => edge.qualifiedName));\n    }\n\n    repeatHead () {\n        const\n            history = this.history,\n            head = history[history.length - 1];\n        // @todo- Akash, write test case if history.length === 0 to pass code coverage\n        if (history.length === 0) {\n            return this;\n        }\n        history.push(head);\n        return this;\n    }\n\n    flush () {\n        const hist = this.history,\n            head = hist[hist.length - 1];\n        hist.length = 0;\n        hist.push(head);\n        return this;\n    }\n\n    isRoot () {\n        return this.name === null;\n    }\n}\n","import {\n    pullableRecent,\n    pullableEnd\n} from './utils';\n\nexport default class ElectricNode {\n    constructor () {\n        this.edges = [];\n        this.listeners = {\n            nextFrame: [],\n            currentFrame: []\n        };\n    }\n\n    addEdges (...nodes) {\n        this.edges.push(...nodes);\n        return this;\n    }\n\n    regListenerForCurrFrame (fn) {\n        const lstnrs = this.listeners.currentFrame;\n        let index = lstnrs.push(pullableRecent(this.edges, fn)) - 1;\n\n        return () => {\n            this.listeners.currentFrame = lstnrs.filter((fn, i) => i !== index);\n        };\n    }\n\n    regListenerForNextFrame (fn) {\n        const lstnrs = this.listeners.nextFrame;\n        let index = lstnrs.push(pullableEnd(this.edges, fn)) - 1;\n\n        return () => {\n            this.listeners.nextFrame = lstnrs.filter((fn, i) => i !== index);\n        };\n    }\n\n    hasNextFrameListener () {\n        return !!this.listeners.nextFrame.length;\n    }\n}\n","import {\n    isSimpleObject,\n    resolver,\n    // upstreamNodes,\n    flat,\n    resolveDependencyOrder,\n    getUpstreamNodes,\n    ForeignSet,\n    fetch,\n    CustomResolver,\n    scheduler\n} from './utils';\nimport Node from './graph-node';\nimport ElectricNode from './electric-node';\n\nexport default class Graph {\n    constructor () {\n        this.qualifiedNodeMap = {};\n        this.retriever = fetch(this.qualifiedNodeMap);\n        this.root = new Node(null, null, { retriever: this.retriever });\n        this.root.resolver = resolver.accumulate;\n\n        this._wholeSet = null;\n        this._propagate = true;\n        this.propagationOverride = {\n            currentFrameListeners: false,\n            nextFrameListeners: false\n        };\n\n        this._schedule = scheduler(() => {\n            let qname;\n            for (qname in this.qualifiedNodeMap) {\n                if (!({}).hasOwnProperty.call(this.qualifiedNodeMap, qname)) {\n                    return;\n                }\n                this.qualifiedNodeMap[qname].flush();\n            }\n        });\n    }\n\n    createNodesFrom (obj, mount) {\n        let val,\n            resolveReqList;\n        const qualifiedNodeMap = this.qualifiedNodeMap,\n            root = this.root,\n            retriever = this.retriever;\n\n        (function rec (objn, qualifiedName, history) {\n            let key,\n                qname,\n                perv,\n                node;\n\n            for (key in objn) {\n                if (!({}).hasOwnProperty.call(objn, key)) {\n                    continue;\n                }\n                qname = `${qualifiedName}${key}`;\n                node = new Node(key, qname, { retriever });\n                qualifiedNodeMap[qname] = node;\n\n                if ((perv = history.perv) !== undefined) {\n                    perv.addDependencies(node);\n                } else {\n                    // top most level entries\n                    root.addDependencies(node);\n                }\n\n                if (isSimpleObject(val = objn[key])) {\n                    rec(val, `${qualifiedName}${key}.`, { perv: node });\n                    node.resolver = resolver.accumulate;\n                } else if (val instanceof CustomResolver) {\n                    node.resolver = val.get();\n                    node.addDependencies(...val.getDependencies().map(qname => qualifiedNodeMap[qname]));\n                } else {\n                    node.resolver = resolver.identity;\n                    node.seed = val;\n                    // node.resolve();\n                }\n            }\n        }(obj, mount === null ? '' : `${mount}.`, {\n            perv: qualifiedNodeMap[mount]\n        }));\n\n        this._wholeSet = new ForeignSet(Object.keys(this.qualifiedNodeMap));\n\n        // Recalculate the model without firing the listeners\n        // @todo selective branch resolve. Currently resolve gets called even for a branch which was updated\n        resolveReqList = this.constructor.getResolvedList(root).concat(root).filter(node => node.requireResolve);\n        resolveReqList.forEach(node => node.resolve());\n        getUpstreamNodes(resolveReqList).forEach(node => node.resolve());\n        return this;\n    }\n\n    getNodeValue (prop) {\n        if (prop in this.qualifiedNodeMap) {\n            return this.qualifiedNodeMap[prop].seed;\n        }\n        return undefined;\n    }\n\n    createElectricNodeOf (props, fnSpec) {\n        const nodes = props.map(prop => this.qualifiedNodeMap[prop]),\n            eNode = new ElectricNode().addEdges(...nodes);\n\n        nodes.forEach(node => node.addElectricNode(eNode));\n        return eNode[`regListenerFor${fnSpec.type}`](fnSpec.fn);\n    }\n\n    update (...params) {\n        let changedSet,\n            upstreamNodes;\n        const\n            electricEdges = [],\n            nodes = params.map((entry) => {\n                entry[0].seed = entry[1];\n                return entry[0];\n            });\n        nodes.forEach(node => node.resolve());\n        electricEdges.push(...flat(...nodes.map(node => node.electricEdges)));\n        changedSet = new ForeignSet(nodes.map(node => node.qualifiedName));\n\n        if (!this._propagate) {\n            this.__execUniqueElectricEdges(electricEdges);\n            this._propagate = true;\n            return this;\n        }\n\n        upstreamNodes = getUpstreamNodes(nodes);\n        upstreamNodes.forEach(upstreamNode => upstreamNode.resolve());\n        changedSet.append(upstreamNodes.map(node => node.qualifiedName));\n        electricEdges.push(...flat(...upstreamNodes.map(node => node.electricEdges)));\n\n        this.__execUniqueElectricEdges(Array.from(new Set(electricEdges)), changedSet);\n        return this;\n    }\n\n    __execUniqueElectricEdges (electricEdges, changedSet) {\n        const\n            cfLstnrs = [], // current frame listeners\n            nfLstnrs = []; // next frame listeners\n        if (changedSet) {\n            const\n                differenceSet = ForeignSet.difference(this._wholeSet, changedSet),\n                entries = differenceSet.toArray();\n\n            entries.forEach(entry => this.qualifiedNodeMap[entry].repeatHead());\n        }\n\n        electricEdges.forEach((e) => {\n            cfLstnrs.push(...e.listeners.currentFrame);\n        });\n        electricEdges.forEach((e) => {\n            nfLstnrs.push(...e.listeners.nextFrame);\n        });\n\n        !this.propagationOverride.currentFrameListeners && cfLstnrs.forEach(fn => fn());\n        !this.propagationOverride.nextFrameListeners && this._schedule(nfLstnrs);\n        this.resetPropagationOverride();\n        return this;\n    }\n\n    resetNodeValue (...qnames) {\n        const nodes = qnames.map(qname => this.qualifiedNodeMap[qname]),\n            args = nodes.map(node => [node, node.seed]);\n        this.update(...args);\n        return this;\n    }\n\n    static getResolvedList (node) {\n        const resolved = [];\n        resolveDependencyOrder(node, resolved, {});\n        return resolved;\n    }\n\n    stopPropagation () {\n        this._propagate = false;\n        return this;\n    }\n\n    resetPropagationOverride () {\n        this.propagationOverride.currentFrameListeners = false;\n        this.propagationOverride.nextFrameListeners = false;\n        return this;\n    }\n\n    setPropagationOverride (key) {\n        this.propagationOverride[`${key}Listeners`] = true;\n        return this;\n    }\n\n    getNodeFromQualifiedName (qname) {\n        return this.qualifiedNodeMap[qname];\n    }\n}\n","import Graph from './graph';\nimport { CustomResolver, fetchAggregator } from './utils';\n\n/**\n * The container class for Hyperdis. Hyperdis is an enabler for observable object with few interesting features like,\n * calculated property, next frame and same frame listeners, multiple listeners etc with a dependency resolving system.\n * It internally uses a graph to hold the hierarchial relationship of a object. Model is merely a container which\n * ties all the components together.\n *\n * @todo Circular dependency detection is not present\n *\n * @example check src/index.spec.js\n * @class\n */\nclass Model {\n    constructor () {\n        this._graph = new Graph();\n        this._lockFlag = false;\n        this._reqQ = [];\n    }\n\n    /**\n     * Static method to create and init the model with an observable seed\n     *\n     * @param {Object} obj The target object which is required to be made observable\n     * @return {Model} instance of the observable object model\n     */\n    static create (obj) {\n        return new Model()._addPropInModel(null, obj);\n    }\n\n    /**\n     * Appends more observable property on the already observable instance. This mutates the original model.\n     *\n     * This function works in two mode. One being\n     * @param {String} mountPoint the property on which the new set of properties will be mounted. If its a nested\n     *                          property then the mountPoint has to be written such a way so it feels like you are\n     *                          accessing the object. If the mount point is not found then he obeservables are added in\n     *                          the root.\n     * @param {Object} The target object which is required to be made observable\n     *\n     * Another being\n     * @param {Object} The target object which is required to be made observable\n     *\n     * @return {Model} instance of the observable object model\n     */\n    append (...params) {\n        let mountPoint,\n            obj;\n\n        if (params.length === 1) {\n            mountPoint = null;\n            obj = params[0];\n        } else {\n            mountPoint = params[0];\n            obj = params[1];\n        }\n\n        this._addPropInModel(mountPoint, obj);\n        return this;\n    }\n\n    /**\n     * Creates a calculated variable from existing variable. This variable can't be updated from outside.\n     * @param {string} mountpoint property path on which the new variable will be placed\n     * @param {string} name name of the variable. If the variable could have hierarchy like `limits.start`\n     * @param {Function} fn funtion where the dependent variables are injected based on the dependency requirement\n     */\n    calculatedProp (...params) {\n        let calculationConfig,\n            customResolver,\n            varName,\n            mount,\n            fetchFn;\n\n        if (params.length > 2) {\n            mount = params[0];\n            varName = params[1];\n            fetchFn = params[2];\n        } else {\n            mount = null;\n            varName = params[0];\n            fetchFn = params[1];\n        }\n\n        calculationConfig = fetchFn(fetchAggregator);\n        customResolver = new CustomResolver(calculationConfig.fn);\n        customResolver.addDependencies(...calculationConfig.dependencies);\n\n        this._addPropInModel(mount, { [varName]: customResolver });\n        return this;\n    }\n\n    // eslint-disable-next-line require-jsdoc\n    _addPropInModel (mountPoint, obj) {\n        this._graph.createNodesFrom(obj, mountPoint);\n        return this;\n    }\n\n    /**\n     * Register a listener in the current frame when a property or group of properties is changed.\n     *\n     * @example\n     * This function takes a single or group of property and handler which is called when any of the properties are\n     * changed.\n     * When a single property is changed the handler is called with two parameter, what was the old value of the state\n     * property and what is the new value.\n     * myState.on('range.start', (oldValue, newValue) => {\n     *      console.log('Value before prop change', oldValue);\n     *      console.log('Value after prop change', newValue);\n     * });\n     *\n     * myState.prop('range.start', 9);\n     * // Output\n     * Value before prop change 1\n     * Value after prop change 9\n     *\n     * If a handler is registered on change of a property which has another state property as value, then the handler\n     * gets called whenever any state property connected to it gets changed\n     *\n     * myState.on('range', (oldValue, newValue) => {\n     *      console.log('Value before prop change', oldValue);\n     *      console.log('Value after prop change', newValue);\n     * });\n     *\n     * myState.prop('range.start', 10);\n     * myState.prop('range.type.absolute', false);\n     *\n     * // Output\n     * Value before prop change\n     * range {\n     *      start: 9,\n     *      end: 5,\n     *      type: {\n     *          absolute: true\n     *      }\n     * }\n     * Value after prop change\n     * range: {\n     *      start: 10,\n     *      end: 5,\n     *      type: {\n     *          absolute: false\n     *      }\n     * }\n     * If a handler is registered with more than one property change then, the handler is called when any of the\n     * properties gets changed. In this cast the handler is called with more than one parameter: each for one state\n     * property which is registered for listening. Each parameter is of type array containing [oldValue, newValue]\n     *\n     * myState.on('range.start', 'range.end', (start, end) => {\n     *      console.log('Start', start);\n     *      console.log('End', end);\n     * });\n     *\n     * myState.prop('range.start', 12);\n     *\n     * // Output\n     * Start [10, 12]\n     * End [5, 5]\n     *\n     * myState.prop('range.end', 7);\n     *\n     * // Output\n     * Start [12, 12]\n     * End [5, 7]\n     *\n     * The on returns a function which is when called the listener registered gets unregistered\n     *\n     * let unsub = myState.on(['range.start', 'range.end'], (start, end) => {\n     *      console.log('Start', start);\n     *      console.log('End', end);\n     * });\n     *\n     * // Unsubscribe\n     * unsub()\n     *\n     * On takes an optional boolean value as the last parameter, which if passed as a true value the handler gets called\n     * during registration itself.\n     *\n     * @param {Array.<String>} props List of properties which is of interest\n     * @param {Function} fn Listener to be executed when any of them is changed. The listener is called with the old\n     *                      value and new value of the properties\n     * @param {*} instantCall When registered if the function is to be triggered with the value of the property\n     *\n     * @return {Function} function to unsubscribe from the listeners registry\n     */\n    on (props, fn, instantCall) {\n        const\n            propsArr = props instanceof Array ? props : [props],\n            // All there listeners will be executed in the current stack frame\n            unsub = this._graph.createElectricNodeOf(propsArr, {\n                type: 'CurrFrame',\n                fn\n            });\n\n        if (instantCall) {\n            // Bar current next frame listeners from getting fired\n            this._graph.stopPropagation().setPropagationOverride('nextFrame').resetNodeValue(...props);\n        }\n        return unsub;\n    }\n\n    /**\n     * Register a listener for the next frame when a property or group of properties is changed.\n     *\n     * @example\n     * See the examples for the on listener\n     *\n     * @param {Array.<String>} props List of properties which is of interest\n     * @param {Function} fn Listener to be executed when any of them is changed. The listener is called with the old\n     *                      value and new value of the properties. Here the oldvalue is last value of the last frame\n     * @param {*} instantCall When registered if the function is to be triggered with the value of the property\n     *\n     * @return {Function} function to unsubscribe from the listeners registry\n     */\n    next (props, fn, instantCall) {\n        const\n            propsArr = props instanceof Array ? props : [props],\n            // All there listeners will be executed at the tick of next animation frame\n            unsub = this._graph.createElectricNodeOf(propsArr, {\n                type: 'NextFrame',\n                fn\n            });\n\n        // @todo check support for this from the graph side\n        if (instantCall) {\n            // Bar current frame listeners from getting fired\n            this._graph.stopPropagation().setPropagationOverride('currentFrame').resetNodeValue(...props);\n        }\n\n        return unsub;\n    }\n\n    /**\n     * Lock queues the request of property change and releases the change when unlock is called. This is helpful when\n     * multiple property is getting called and the model listeners are to be fired once at the end of update.\n     *\n     * @return {Model} instance of the model\n     */\n    lock () {\n        this._lockFlag = true;\n        this._reqQ.length = 0;\n        return this;\n    }\n\n    /**\n     * Unlock unleashes the change done after the lock was called.\n\n     * @return {Model} instance of the model\n     */\n    unlock () {\n        this._lockFlag = false;\n        this.setProp(...this._reqQ);\n        this._reqQ.length = 0;\n        return this;\n    }\n\n    /**\n     * This acts as getter and setter. If the function is called by passing only one argument, it retrieve the value\n     * associated with the property. If the same function is called using two parameters, first one being the property\n     * and second one being the value, then the value is set for the property and the handlers are called (if any)\n     * which got registered using the on function\n     *\n     * Getter\n     * @param {string} prop property path whose value to be retrieved\n     * @return {Object} value of the property at the time of call\n     *\n     * Setter\n     * @param {string} property property path whose value to be ser\n     * @return {Model} instance of the model\n     */\n    prop (...params) {\n        let prop,\n            val,\n            len;\n\n        switch (len = params.length) {\n        case 1:\n            prop = params[0];\n            break;\n\n        case 2:\n            prop = params[0];\n            val = params[1];\n            break;\n\n        default:\n            return this;\n        }\n\n        if (len === 2) {\n            this._lockFlag ? this._reqQ.push([prop, val]) : this.setProp([prop, val]);\n            return this;\n        }\n\n        return this._graph.getNodeValue(prop);\n    }\n\n    // eslint-disable-next-line require-jsdoc\n    setProp (...props) {\n        // Filter out the calculated variables, so that it cant be changed from outside\n        // @todo if a node is not leafValue, and change is called, ignore it too\n        // props = props.filter(prop => !(VirtualObj.walkTill(prop[0].split('.'), this._vObj).leafValue()\n        //     instanceof CalculatedVar));\n\n        if (props.length === 0) {\n            return this;\n        }\n\n        this._graph.update(...props.map(prop => [this._graph.getNodeFromQualifiedName(prop[0]), prop[1]]));\n        return this;\n    }\n\n    /**\n     * Retrieves the graph representation of the object\n     * @return {Graph} instance of the graph associated to the model\n     */\n    graph () {\n        return this._graph;\n    }\n\n    /**\n     * Get serialized data from the model\n     *\n     * @return {Object} Serialized data\n     */\n    serialize () {\n        return this._graph.root.seed;\n    }\n}\n\nexport default Model;\n","import Model from './model';\n\nexport default Model;\n"],"sourceRoot":""}