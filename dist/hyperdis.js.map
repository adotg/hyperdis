{"version":3,"sources":["webpack://hyperdis/webpack/universalModuleDefinition","webpack://hyperdis/webpack/bootstrap","webpack://hyperdis/./src/utils/set.js","webpack://hyperdis/./src/utils/index.js","webpack://hyperdis/./src/graph-node.js","webpack://hyperdis/./src/electric-node.js","webpack://hyperdis/./src/graph.js","webpack://hyperdis/./src/model.js","webpack://hyperdis/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","makeEntry","arr","sCon","forEach","elem","undefined","ForeignSet","_classCallCheck","this","_set","keys","set1","set2","filteredKeys","s1","s2","push","isSimpleObject","obj","_typeof","toString","constructor","match","win","getTimeBasedId","__lastTime","Date","getTime","__id","flat","params","res","param","apply","_toConsumableArray","scheduler","onFinishCallback","isPrintMode","queue","animationFrame","listeners","payload","console","log","callback","setTimeout","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","reqAnimFrame","tempQ","slice","length","fns","reduce","store","fn","map","unique","fetch","namedNode","_len","arguments","Array","_key","node","qualifiedName","seed","fetchAggregator","_len2","_key2","dependencies","getUpstreamNodes","list","rec","qname","placedIndex","preArr","postArr","concat","outgoingEdges","resolver","accumulate","_len3","_key3","resp","nodeDetails","assign","_defineProperty","identity","shallowMerge","target","TypeError","to","_len4","varArgs","_key4","index","nextSource","nextKey","CustomResolver","utils_classCallCheck","dep","_dep","GraphNode","options","graph_node_classCallCheck","edges","_seed","requireResolve","retriever","history","electricEdges","_edges","_this","entry","graph_node_toConsumableArray","retrieveDetails","edge","head","hist","ElectricNode","electric_node_classCallCheck","nextFrame","currentFrame","lstnrs","nodes","nFn","pullableRecent","filter","_this2","pullableEnd","Graph","graph_classCallCheck","qualifiedNodeMap","graph_node","_wholeSet","_propagate","propagationOverride","currentFrameListeners","nextFrameListeners","_schedule","flushTarget","flush","mount","val","resolveReqList","objn","perv","addDependencies","_node","graph_toConsumableArray","getDependencies","set","getResolvedList","resolve","prop","props","fnSpec","_ref","eNode","electric_node","addEdges","addElectricNode","type","changedSet","upstreamNodes","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","iterator","next","done","err","return","__execUniqueElectricEdges","upstreamNode","append","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","from","Set","_this3","cfLstnrs","nfLstnrs","difference","toArray","repeatHead","e","resetPropagationOverride","_this4","qnames","args","update","resolved","resolveDependencyOrder","resolveMap","neighbour","isRoot","model","Model","model_classCallCheck","_graph","graph","_lockFlag","_reqQ","mountPoint","_addPropInModel","_customResolver","calculationConfig","customResolver","varName","fetchFn","model_toConsumableArray","model_defineProperty","createNodesFrom","instantCall","_graph$stopPropagatio","propsArr","unsub","createElectricNodeOf","stopPropagation","setPropagationOverride","resetNodeValue","_graph$stopPropagatio2","setProp","len","getNodeValue","getNodeFromQualifiedName","__webpack_exports__"],"mappings":"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","file":"hyperdis.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hyperdis\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hyperdis\"] = factory();\n\telse\n\t\troot[\"hyperdis\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const makeEntry = (arr, sCon) => {\n    arr.forEach((elem) => {\n        if (elem === undefined || elem === null) {\n            return;\n        }\n        sCon[elem] = 1;\n    });\n};\n\nexport default class ForeignSet {\n    constructor (arr) {\n        this._set = {};\n        makeEntry(arr, this._set);\n    }\n\n    append (arr) {\n        makeEntry(arr, this._set);\n        return this;\n    }\n\n    toArray () {\n        return Object.keys(this._set);\n    }\n\n    static difference (set1, set2) {\n        let key;\n        const filteredKeys = [],\n            s1 = set1._set,\n            s2 = set2._set;\n        for (key in s1) {\n            if (!({}).hasOwnProperty.call(s1, key)) {\n                continue;\n            }\n            if (key in s2) {\n                continue;\n            }\n            filteredKeys.push(key);\n        }\n        return new ForeignSet(filteredKeys);\n    }\n}\n","/* global window */\n\nimport ForeignSet from './set';\n\nconst\n    isSimpleObject = (obj) => {\n        let token;\n        if (typeof obj === 'object') {\n            if (obj === null) { return false; }\n            token = Object.prototype.toString.call(obj);\n            if (token === '[object Object]') {\n                return (obj.constructor.toString().match(/^function (.*)\\(\\)/m) || [])[1] === 'Object';\n            }\n        }\n        return false;\n    },\n    minMsThreshold = 16,\n    /* istanbul ignore next */win = typeof window === 'undefined' ? (this || {}) : window,\n    // eslint-disable-next-line require-jsdoc\n    /* istanbul ignore next */ reqAnimFrame = (isPrintMode) => {\n        if (isPrintMode) {\n            console.log(`HYPERDIS: isPrintMode is ${isPrintMode}, using setTimeout now`);\n            return function (callback) {\n                setTimeout(callback, minMsThreshold);\n            };\n        }\n\n        console.log(`HYPERDIS: isPrintMode is ${isPrintMode}, using requestAnimationFrame now`);\n        return win.requestAnimationFrame ||\n            win.webkitRequestAnimationFrame ||\n            win.mozRequestAnimationFrame ||\n            win.oRequestAnimationFrame ||\n            win.msRequestAnimationFrame ||\n            function (callback) {\n                setTimeout(callback, minMsThreshold);\n            };\n    },\n\n    getTimeBasedId = () => {\n        if (getTimeBasedId.__lastTime === new Date().getTime()) {\n            return (getTimeBasedId.__lastTime).toString() + (getTimeBasedId.__id++).toString();\n        }\n\n        getTimeBasedId.__id = 0;\n        getTimeBasedId.__lastTime = new Date().getTime();\n        return (getTimeBasedId.__lastTime).toString() + (getTimeBasedId.__id++).toString();\n    },\n    pullableRecent = (nodes, fn) => {\n        let nFn = () => {\n            fn(...nodes.map((node) => {\n                const\n                    hist = node.history,\n                    l = hist.length - 1;\n                return [hist[l - 1 < 0 ? 0 : l - 1], hist[l]];\n            }));\n        };\n        nFn.__id = getTimeBasedId();\n        return nFn;\n    },\n    pullableEnd = (nodes, fn) => {\n        let nFn = () => {\n            fn(...nodes.map((node) => {\n                const hist = node.history;\n                return [hist[0], hist[hist.length - 1]];\n            }));\n        };\n        nFn.__id = getTimeBasedId();\n        return nFn;\n    },\n    unique = fns => fns\n                    .reduce((store, fn) => {\n                // @warn function with side effect, it mutates the store passed during initialization\n                        if (fn.__id in store.map) {\n                            return store;\n                        }\n\n                        store.map[fn.__id] = 1;\n                        store.unique.push(fn);\n\n                        return store;\n                    }, { map: {}, unique: [] })\n                    .unique,\n    compose = fns => () => {\n        fns.forEach(fn => fn());\n    },\n    flat = (params) => {\n        const res = [];\n        params.forEach(param => res.push(...param));\n        return res;\n    },\n    identityMap = arrays => arrays,\n    splitPathProp = (path) => {\n        const pathArr = path.split('.'),\n            len = pathArr.length;\n        return [pathArr.slice(0, len - 1), pathArr[len - 1]];\n    },\n    scheduler = (onFinishCallback, isPrintMode) => {\n        let queue = [],\n            animationFrame = null;\n\n        onFinishCallback = onFinishCallback &&\n            typeof onFinishCallback === 'function' && onFinishCallback || (() => { });\n\n        return (listeners, payload) => {\n            [].push.apply(queue, listeners);\n            if (animationFrame === null) {\n                animationFrame = reqAnimFrame(isPrintMode)(() => {\n                    const tempQ = queue.slice(0);\n                    queue.length = 0;\n                    animationFrame = null;\n\n                    unique(tempQ).forEach(fn => fn());\n                    onFinishCallback(payload);\n                });\n            }\n        };\n    },\n    fetch = namedNode => (...params) => params.map((param) => {\n        const node = namedNode[param];\n        return {\n            name: node.name,\n            qualifiedName: node.qualifiedName,\n            value: node.seed\n        };\n    }),\n    fetchAggregator = (...params) => ({\n        dependencies: params.slice(0, params.length - 1),\n        fn: params[params.length - 1]\n    }),\n    getUpstreamNodes = (list) => {\n        let res = [];\n        const map = {};\n        list.forEach(node => map[node.qualifiedName] = -1);\n        function rec (arr) {\n            arr.forEach((node) => {\n                let qname,\n                    placedIndex,\n                    preArr,\n                    postArr;\n                if (!((qname = node.qualifiedName) in map)) {\n                    map[qname] = res.push(node) - 1;\n                } else {\n                    placedIndex = map[qname];\n                    if (placedIndex !== -1 && placedIndex !== res.length - 1) {\n                        // If not the last element, readjust the array so that the later dependency position is saved\n                        preArr = res.slice(0, placedIndex);\n                        postArr = res.slice(placedIndex + 1);\n                        res = preArr.concat(postArr);\n\n                        // reset the index in map\n                        postArr.forEach((elem, i) => map[elem.qualifiedName] = i + preArr.length);\n                        map[qname] = res.push(node) - 1;\n                    }\n                }\n                rec(node.outgoingEdges);\n            });\n        }\n        rec(list);\n        return res;\n    },\n    resolver = {\n        accumulate: (...params) => {\n            const resp = {};\n            params.forEach((nodeDetails) => {\n                Object.assign(resp, { [nodeDetails.name]: nodeDetails.value });\n            });\n            return resp;\n        },\n        identity: nodeDetails => nodeDetails.value\n    };\n\nfunction resolveDependencyOrder (node, resolved, resolveMap) {\n    let qname;\n    node.edges.forEach((neighbour) => {\n        resolveDependencyOrder(neighbour, resolved, resolveMap);\n    });\n\n    if (node.isRoot() || (qname = node.qualifiedName) in resolveMap) {\n        return;\n    }\n    resolved.push(node);\n    resolveMap[qname] = 1;\n}\n\nfunction shallowMerge(target, ...varArgs) {\n    if (target == null) { // TypeError if undefined or null\n        throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    let to = Object(target);\n\n    for (let index = 0; index < varArgs.length; index++) {\n        let nextSource = varArgs[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n            for (let nextKey in nextSource) {\n                // Avoid bugs when hasOwnProperty is shadowed\n                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                    to[nextKey] = nextSource[nextKey];\n                }\n            }\n        }\n    }\n    return to;\n}\n\nclass CustomResolver {\n    constructor (resolver) {\n        this.fn = resolver;\n        this.dep = [];\n    }\n\n    addDependencies(...dep) {\n        this.dep.push(...dep);\n        return this;\n    }\n\n    getDependencies () {\n        return this.dep;\n    }\n\n    get () {\n        return this.fn;\n    }\n}\n\nexport {\n    shallowMerge,\n    isSimpleObject,\n    scheduler,\n    compose,\n    flat,\n    identityMap,\n    pullableEnd,\n    pullableRecent,\n    unique,\n    splitPathProp,\n    resolver,\n    ForeignSet,\n    resolveDependencyOrder,\n    fetch,\n    fetchAggregator,\n    CustomResolver,\n    getUpstreamNodes\n};\n","export default class GraphNode {\n    constructor (name, qualifiedName, options) {\n        /* istanbul ignore next */options = options || {};\n        this.name = name;\n        this.qualifiedName = qualifiedName;\n        this.edges = [];\n        this.outgoingEdges = [];\n        this._seed = null;\n        this.requireResolve = true;\n        this.retriever = options.retriever;\n        this.history = [];\n        this.resolver = null;\n        this.electricEdges = [];\n    }\n\n    addDependencies (...dep) {\n        this.edges.push(...dep);\n        dep.forEach(entry => entry.outgoingEdges.push(this));\n        return this;\n    }\n\n    addElectricNode (node) {\n        this.electricEdges.push(node);\n        return this;\n    }\n\n    get seed () {\n        return this._seed;\n    }\n\n    set seed (value) {\n        this._seed = value;\n        this.requireResolve = true;\n        return this;\n    }\n\n    resolve () {\n        this.seed = this.resolver(...this.retrieveDetails());\n        this.history.push(this.seed);\n        this.requireResolve = false;\n        return this;\n    }\n\n    retrieveDetails () {\n        if (this.edges.length === 0) {\n            return [{\n                name: this.name,\n                qualifiedName: this.qualifiedName,\n                value: this.seed\n            }];\n        }\n        return this.retriever(...this.edges.map(edge => edge.qualifiedName));\n    }\n\n    repeatHead () {\n        const\n            history = this.history,\n            head = history[history.length - 1];\n        // @todo- Akash, write test case if history.length === 0 to pass code coverage\n        if (history.length === 0) {\n            return this;\n        }\n        history.push(head);\n        return this;\n    }\n\n    flush () {\n        const hist = this.history,\n            head = hist[hist.length - 1];\n        hist.length = 0;\n        hist.push(head);\n        return this;\n    }\n\n    isRoot () {\n        return this.name === null;\n    }\n}\n","import {\n    pullableRecent,\n    pullableEnd\n} from './utils';\n\nexport default class ElectricNode {\n    constructor () {\n        this.edges = [];\n        this.listeners = {\n            nextFrame: [],\n            currentFrame: []\n        };\n    }\n\n    addEdges (...nodes) {\n        this.edges.push(...nodes);\n        return this;\n    }\n\n    regListenerForCurrFrame (fn) {\n        const lstnrs = this.listeners.currentFrame;\n        let index = lstnrs.push(pullableRecent(this.edges, fn)) - 1;\n\n        return () => {\n            this.listeners.currentFrame = lstnrs.filter((fn, i) => i !== index);\n        };\n    }\n\n    regListenerForNextFrame (fn) {\n        const lstnrs = this.listeners.nextFrame;\n        let index = lstnrs.push(pullableEnd(this.edges, fn)) - 1;\n\n        return () => {\n            this.listeners.nextFrame = lstnrs.filter((fn, i) => i !== index);\n        };\n    }\n\n    hasNextFrameListener () {\n        return !!this.listeners.nextFrame.length;\n    }\n}\n","import {\n    isSimpleObject,\n    resolver,\n    // upstreamNodes,\n    flat,\n    resolveDependencyOrder,\n    getUpstreamNodes,\n    ForeignSet,\n    fetch,\n    CustomResolver,\n    scheduler,\n    shallowMerge\n} from './utils';\nimport Node from './graph-node';\nimport ElectricNode from './electric-node';\n\nexport default class Graph {\n    constructor (options) {\n        options = shallowMerge({}, { isPrintMode: false }, options);\n        this.qualifiedNodeMap = {};\n        this.retriever = fetch(this.qualifiedNodeMap);\n        this.root = new Node(null, null, { retriever: this.retriever });\n        this.root.resolver = resolver.accumulate;\n\n        this._wholeSet = null;\n        this._propagate = true;\n        this.propagationOverride = {\n            currentFrameListeners: false,\n            nextFrameListeners: false\n        };\n\n        this._schedule = scheduler((payload) => {\n            let qname;\n            for (qname in payload.flushTarget) {\n                if (!({}).hasOwnProperty.call(this.qualifiedNodeMap, qname)) {\n                    return;\n                }\n                this.qualifiedNodeMap[qname].flush();\n            }\n        }, options.isPrintMode);\n    }\n\n    createNodesFrom (obj, mount) {\n        let val,\n            resolveReqList;\n        const qualifiedNodeMap = this.qualifiedNodeMap,\n            root = this.root,\n            retriever = this.retriever;\n\n        (function rec (objn, qualifiedName, history) {\n            let key,\n                qname,\n                perv,\n                node;\n\n            for (key in objn) {\n                if (!({}).hasOwnProperty.call(objn, key)) {\n                    continue;\n                }\n                qname = `${qualifiedName}${key}`;\n                node = new Node(key, qname, { retriever });\n                qualifiedNodeMap[qname] = node;\n\n                if ((perv = history.perv) !== undefined) {\n                    perv.addDependencies(node);\n                } else {\n                    // top most level entries\n                    root.addDependencies(node);\n                }\n\n                if (isSimpleObject(val = objn[key])) {\n                    rec(val, `${qualifiedName}${key}.`, { perv: node });\n                    node.resolver = resolver.accumulate;\n                } else if (val instanceof CustomResolver) {\n                    node.resolver = val.get();\n                    node.addDependencies(...val.getDependencies().map(qname => qualifiedNodeMap[qname]));\n                } else {\n                    node.resolver = resolver.identity;\n                    node.seed = val;\n                    // node.resolve();\n                }\n            }\n        }(obj, mount === null ? '' : `${mount}.`, {\n            perv: qualifiedNodeMap[mount]\n        }));\n\n        this._wholeSet = new ForeignSet(Object.keys(this.qualifiedNodeMap));\n\n        // Recalculate the model without firing the listeners\n        // @todo selective branch resolve. Currently resolve gets called even for a branch which was updated\n        resolveReqList = this.constructor.getResolvedList(root).concat(root).filter(node => node.requireResolve);\n        resolveReqList.forEach(node => node.resolve());\n        getUpstreamNodes(resolveReqList).forEach(node => node.resolve());\n        return this;\n    }\n\n    getNodeValue (prop) {\n        if (prop in this.qualifiedNodeMap) {\n            return this.qualifiedNodeMap[prop].seed;\n        }\n        return undefined;\n    }\n\n    createElectricNodeOf (props, fnSpec) {\n        const nodes = props.map(prop => this.qualifiedNodeMap[prop]),\n            eNode = new ElectricNode().addEdges(...nodes);\n\n        nodes.forEach(node => node.addElectricNode(eNode));\n        return eNode[`regListenerFor${fnSpec.type}`](fnSpec.fn);\n    }\n\n    update (params) {\n        let changedSet,\n            upstreamNodes;\n        const\n            electricEdges = [],\n            nodes = params.map((entry) => {\n                entry[0].seed = entry[1];\n                return entry[0];\n            });\n        nodes.forEach(node => node.resolve());\n        for (let val of flat(nodes.map(node => node.electricEdges))) {\n            electricEdges.push(val);\n        }\n        changedSet = new ForeignSet(nodes.map(node => node.qualifiedName));\n\n        if (!this._propagate) {\n            this.__execUniqueElectricEdges(electricEdges);\n            this._propagate = true;\n            return this;\n        }\n\n        upstreamNodes = getUpstreamNodes(nodes);\n        upstreamNodes.forEach(upstreamNode => upstreamNode.resolve());\n        changedSet.append(upstreamNodes.map(node => node.qualifiedName));\n        for (let val of flat(upstreamNodes.map(node => node.electricEdges))) {\n            electricEdges.push(val);\n        }\n\n        this.__execUniqueElectricEdges(Array.from(new Set(electricEdges)), changedSet);\n        return this;\n    }\n\n    __execUniqueElectricEdges (electricEdges, changedSet) {\n        const\n            cfLstnrs = [], // current frame listeners\n            nfLstnrs = []; // next frame listeners\n        if (changedSet) {\n            const\n                differenceSet = ForeignSet.difference(this._wholeSet, changedSet),\n                entries = differenceSet.toArray();\n\n            entries.forEach(entry => this.qualifiedNodeMap[entry].repeatHead());\n        }\n\n        electricEdges.forEach((e) => {\n            cfLstnrs.push(...e.listeners.currentFrame);\n        });\n        electricEdges.forEach((e) => {\n            nfLstnrs.push(...e.listeners.nextFrame);\n        });\n\n        !this.propagationOverride.currentFrameListeners && cfLstnrs.forEach(fn => fn());\n        !this.propagationOverride.nextFrameListeners && this._schedule(nfLstnrs, { flushTarget: changedSet });\n        this.resetPropagationOverride();\n        return this;\n    }\n\n    resetNodeValue (...qnames) {\n        const nodes = qnames.map(qname => this.qualifiedNodeMap[qname]),\n            args = nodes.map(node => [node, node.seed]);\n        this.update(args);\n        return this;\n    }\n\n    static getResolvedList (node) {\n        const resolved = [];\n        resolveDependencyOrder(node, resolved, {});\n        return resolved;\n    }\n\n    stopPropagation () {\n        this._propagate = false;\n        return this;\n    }\n\n    resetPropagationOverride () {\n        this.propagationOverride.currentFrameListeners = false;\n        this.propagationOverride.nextFrameListeners = false;\n        return this;\n    }\n\n    setPropagationOverride (key) {\n        this.propagationOverride[`${key}Listeners`] = true;\n        return this;\n    }\n\n    getNodeFromQualifiedName (qname) {\n        return this.qualifiedNodeMap[qname];\n    }\n}\n","import Graph from './graph';\nimport { CustomResolver, fetchAggregator, shallowMerge } from './utils';\n\n/**\n * The container class for Hyperdis. Hyperdis is an enabler for observable object with few interesting features like,\n * calculated property, next frame and same frame listeners, multiple listeners etc with a dependency resolving system.\n * It internally uses a graph to hold the hierarchial relationship of a object. Model is merely a container which\n * ties all the components together.\n *\n * @todo Circular dependency detection is not present\n *\n * @example check src/index.spec.js\n * @class\n */\n\nclass Model {\n    // eslint-disable-next-line require-jsdoc\n    constructor (options) {\n        options = shallowMerge({}, { isPrintMode: false }, options);\n        console.log('HYPERDIST RECEIVED OPTIONS: ', options);\n        this._graph = new Graph(options);\n        this._lockFlag = false;\n        this._reqQ = [];\n    }\n\n    /**\n     * Static method to create and init the model with an observable seed\n     *\n     * @param {Object} obj The target object which is required to be made observable\n     * @return {Model} instance of the observable object model\n     */\n    static create (obj, options) {\n        return new Model(options)._addPropInModel(null, obj);\n    }\n\n    /**\n     * Appends more observable property on the already observable instance. This mutates the original model.\n     *\n     * This function works in two mode. One being\n     * @param {String} mountPoint the property on which the new set of properties will be mounted. If its a nested\n     *                          property then the mountPoint has to be written such a way so it feels like you are\n     *                          accessing the object. If the mount point is not found then he obeservables are added in\n     *                          the root.\n     * @param {Object} The target object which is required to be made observable\n     *\n     * Another being\n     * @param {Object} The target object which is required to be made observable\n     *\n     * @return {Model} instance of the observable object model\n     */\n    append (...params) {\n        let mountPoint,\n            obj;\n\n        if (params.length === 1) {\n            mountPoint = null;\n            obj = params[0];\n        } else {\n            mountPoint = params[0];\n            obj = params[1];\n        }\n\n        this._addPropInModel(mountPoint, obj);\n        return this;\n    }\n\n    /**\n     * Creates a calculated variable from existing variable. This variable can't be updated from outside.\n     * @param {string} mountpoint property path on which the new variable will be placed\n     * @param {string} name name of the variable. If the variable could have hierarchy like `limits.start`\n     * @param {Function} fn funtion where the dependent variables are injected based on the dependency requirement\n     */\n    calculatedProp (...params) {\n        let calculationConfig,\n            customResolver,\n            varName,\n            mount,\n            fetchFn;\n\n        if (params.length > 2) {\n            mount = params[0];\n            varName = params[1];\n            fetchFn = params[2];\n        } else {\n            mount = null;\n            varName = params[0];\n            fetchFn = params[1];\n        }\n\n        calculationConfig = fetchFn(fetchAggregator);\n        customResolver = new CustomResolver(calculationConfig.fn);\n        customResolver.addDependencies(...calculationConfig.dependencies);\n\n        this._addPropInModel(mount, { [varName]: customResolver });\n        return this;\n    }\n\n    // eslint-disable-next-line require-jsdoc\n    _addPropInModel (mountPoint, obj) {\n        this._graph.createNodesFrom(obj, mountPoint);\n        return this;\n    }\n\n    /**\n     * Register a listener in the current frame when a property or group of properties is changed.\n     *\n     * @example\n     * This function takes a single or group of property and handler which is called when any of the properties are\n     * changed.\n     * When a single property is changed the handler is called with two parameter, what was the old value of the state\n     * property and what is the new value.\n     * myState.on('range.start', (oldValue, newValue) => {\n     *      console.log('Value before prop change', oldValue);\n     *      console.log('Value after prop change', newValue);\n     * });\n     *\n     * myState.prop('range.start', 9);\n     * // Output\n     * Value before prop change 1\n     * Value after prop change 9\n     *\n     * If a handler is registered on change of a property which has another state property as value, then the handler\n     * gets called whenever any state property connected to it gets changed\n     *\n     * myState.on('range', (oldValue, newValue) => {\n     *      console.log('Value before prop change', oldValue);\n     *      console.log('Value after prop change', newValue);\n     * });\n     *\n     * myState.prop('range.start', 10);\n     * myState.prop('range.type.absolute', false);\n     *\n     * // Output\n     * Value before prop change\n     * range {\n     *      start: 9,\n     *      end: 5,\n     *      type: {\n     *          absolute: true\n     *      }\n     * }\n     * Value after prop change\n     * range: {\n     *      start: 10,\n     *      end: 5,\n     *      type: {\n     *          absolute: false\n     *      }\n     * }\n     * If a handler is registered with more than one property change then, the handler is called when any of the\n     * properties gets changed. In this cast the handler is called with more than one parameter: each for one state\n     * property which is registered for listening. Each parameter is of type array containing [oldValue, newValue]\n     *\n     * myState.on('range.start', 'range.end', (start, end) => {\n     *      console.log('Start', start);\n     *      console.log('End', end);\n     * });\n     *\n     * myState.prop('range.start', 12);\n     *\n     * // Output\n     * Start [10, 12]\n     * End [5, 5]\n     *\n     * myState.prop('range.end', 7);\n     *\n     * // Output\n     * Start [12, 12]\n     * End [5, 7]\n     *\n     * The on returns a function which is when called the listener registered gets unregistered\n     *\n     * let unsub = myState.on(['range.start', 'range.end'], (start, end) => {\n     *      console.log('Start', start);\n     *      console.log('End', end);\n     * });\n     *\n     * // Unsubscribe\n     * unsub()\n     *\n     * On takes an optional boolean value as the last parameter, which if passed as a true value the handler gets called\n     * during registration itself.\n     *\n     * @param {Array.<String>} props List of properties which is of interest\n     * @param {Function} fn Listener to be executed when any of them is changed. The listener is called with the old\n     *                      value and new value of the properties\n     * @param {*} instantCall When registered if the function is to be triggered with the value of the property\n     *\n     * @return {Function} function to unsubscribe from the listeners registry\n     */\n    on (props, fn, instantCall) {\n        const\n            propsArr = props instanceof Array ? props : [props],\n            // All there listeners will be executed in the current stack frame\n            unsub = this._graph.createElectricNodeOf(propsArr, {\n                type: 'CurrFrame',\n                fn\n            });\n\n        if (instantCall) {\n            // Bar current next frame listeners from getting fired\n            this._graph.stopPropagation().setPropagationOverride('nextFrame').resetNodeValue(...props);\n        }\n        return unsub;\n    }\n\n    /**\n     * Register a listener for the next frame when a property or group of properties is changed.\n     *\n     * @example\n     * See the examples for the on listener\n     *\n     * @param {Array.<String>} props List of properties which is of interest\n     * @param {Function} fn Listener to be executed when any of them is changed. The listener is called with the old\n     *                      value and new value of the properties. Here the oldvalue is last value of the last frame\n     * @param {*} instantCall When registered if the function is to be triggered with the value of the property\n     *\n     * @return {Function} function to unsubscribe from the listeners registry\n     */\n    next (props, fn, instantCall) {\n        const\n            propsArr = props instanceof Array ? props : [props],\n            // All there listeners will be executed at the tick of next animation frame\n            unsub = this._graph.createElectricNodeOf(propsArr, {\n                type: 'NextFrame',\n                fn\n            });\n\n        // @todo check support for this from the graph side\n        if (instantCall) {\n            // Bar current frame listeners from getting fired\n            this._graph.stopPropagation().setPropagationOverride('currentFrame').resetNodeValue(...props);\n        }\n\n        return unsub;\n    }\n\n    /**\n     * Lock queues the request of property change and releases the change when unlock is called. This is helpful when\n     * multiple property is getting called and the model listeners are to be fired once at the end of update.\n     *\n     * @return {Model} instance of the model\n     */\n    lock () {\n        this._lockFlag = true;\n        this._reqQ.length = 0;\n        return this;\n    }\n\n    /**\n     * Unlock unleashes the change done after the lock was called.\n\n     * @return {Model} instance of the model\n     */\n    unlock () {\n        this._lockFlag = false;\n        this.setProp(this._reqQ);\n        this._reqQ.length = 0;\n        return this;\n    }\n\n    /**\n     * This acts as getter and setter. If the function is called by passing only one argument, it retrieve the value\n     * associated with the property. If the same function is called using two parameters, first one being the property\n     * and second one being the value, then the value is set for the property and the handlers are called (if any)\n     * which got registered using the on function\n     *\n     * Getter\n     * @param {string} prop property path whose value to be retrieved\n     * @return {Object} value of the property at the time of call\n     *\n     * Setter\n     * @param {string} property property path whose value to be ser\n     * @return {Model} instance of the model\n     */\n    prop (...params) {\n        let prop,\n            val,\n            len;\n\n        switch (len = params.length) {\n        case 1:\n            prop = params[0];\n            break;\n\n        case 2:\n            prop = params[0];\n            val = params[1];\n            break;\n\n        default:\n            return this;\n        }\n\n        if (len === 2) {\n            this._lockFlag ? this._reqQ.push([prop, val]) : this.setProp([[prop, val]]);\n            return this;\n        }\n\n        return this._graph.getNodeValue(prop);\n    }\n\n    // eslint-disable-next-line require-jsdoc\n    setProp (props) {\n        // Filter out the calculated variables, so that it cant be changed from outside\n        // @todo if a node is not leafValue, and change is called, ignore it too\n        // props = props.filter(prop => !(VirtualObj.walkTill(prop[0].split('.'), this._vObj).leafValue()\n        //     instanceof CalculatedVar));\n\n        if (props.length === 0) {\n            return this;\n        }\n\n        this._graph.update(props.map(prop => [this._graph.getNodeFromQualifiedName(prop[0]), prop[1]]));\n        return this;\n    }\n\n    /**\n     * Retrieves the graph representation of the object\n     * @return {Graph} instance of the graph associated to the model\n     */\n    graph () {\n        return this._graph;\n    }\n\n    /**\n     * Get serialized data from the model\n     *\n     * @return {Object} Serialized data\n     */\n    serialize () {\n        return this._graph.root.seed;\n    }\n}\n\nexport default Model;\n","import Model from './model';\n\nexport default Model;\n"],"sourceRoot":""}