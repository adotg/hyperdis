{"version":3,"sources":["webpack://hyperdis/webpack/universalModuleDefinition","webpack://hyperdis/webpack/bootstrap","webpack://hyperdis/./src/utils/set.js","webpack://hyperdis/./src/utils/index.js","webpack://hyperdis/./src/graph-node.js","webpack://hyperdis/./src/electric-node.js","webpack://hyperdis/./src/graph.js","webpack://hyperdis/./src/model.js","webpack://hyperdis/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","makeEntry","arr","sCon","forEach","elem","ForeignSet","this","_set","keys","set1","set2","filteredKeys","s1","s2","push","isSimpleObject","obj","toString","constructor","match","win","getTimeBasedId","__lastTime","Date","getTime","__id","flat","params","res","param","scheduler","onFinishCallback","isPrintMode","queue","animationFrame","listeners","payload","apply","callback","setTimeout","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","reqAnimFrame","fns","tempQ","slice","length","reduce","store","fn","map","unique","fetchAggregator","dependencies","getUpstreamNodes","list","node","qualifiedName","rec","qname","placedIndex","preArr","postArr","concat","outgoingEdges","resolver","resp","nodeDetails","assign","shallowMerge","target","TypeError","to","varArgs","index","nextSource","nextKey","CustomResolver","dep","GraphNode","options","edges","_seed","requireResolve","retriever","history","electricEdges","entry","seed","retrieveDetails","edge","head","hist","ElectricNode","nextFrame","currentFrame","lstnrs","nodes","nFn","pullableRecent","filter","pullableEnd","Graph","namedNode","qualifiedNodeMap","Node","_wholeSet","_propagate","propagationOverride","currentFrameListeners","nextFrameListeners","_schedule","flushTarget","flush","mount","val","resolveReqList","objn","perv","undefined","addDependencies","getDependencies","getResolvedList","resolve","prop","props","fnSpec","eNode","addEdges","addElectricNode","type","changedSet","upstreamNodes","__execUniqueElectricEdges","upstreamNode","append","Array","from","Set","cfLstnrs","nfLstnrs","difference","toArray","repeatHead","e","resetPropagationOverride","qnames","args","update","resolved","resolveDependencyOrder","resolveMap","neighbour","isRoot","Model","_graph","_lockFlag","_reqQ","mountPoint","_addPropInModel","calculationConfig","customResolver","varName","fetchFn","createNodesFrom","instantCall","propsArr","unsub","createElectricNodeOf","stopPropagation","setPropagationOverride","resetNodeValue","setProp","len","getNodeValue","getNodeFromQualifiedName"],"mappings":"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","file":"hyperdis.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hyperdis\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hyperdis\"] = factory();\n\telse\n\t\troot[\"hyperdis\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const makeEntry = (arr, sCon) => {\n    arr.forEach((elem) => {\n        if (elem === undefined || elem === null) {\n            return;\n        }\n        sCon[elem] = 1;\n    });\n};\n\nexport default class ForeignSet {\n    constructor (arr) {\n        this._set = {};\n        makeEntry(arr, this._set);\n    }\n\n    append (arr) {\n        makeEntry(arr, this._set);\n        return this;\n    }\n\n    toArray () {\n        return Object.keys(this._set);\n    }\n\n    static difference (set1, set2) {\n        let key;\n        const filteredKeys = [],\n            s1 = set1._set,\n            s2 = set2._set;\n        for (key in s1) {\n            if (!({}).hasOwnProperty.call(s1, key)) {\n                continue;\n            }\n            if (key in s2) {\n                continue;\n            }\n            filteredKeys.push(key);\n        }\n        return new ForeignSet(filteredKeys);\n    }\n}\n","/* global window */\n\nimport ForeignSet from './set';\n\nconst\n    isSimpleObject = (obj) => {\n        let token;\n        if (typeof obj === 'object') {\n            if (obj === null) { return false; }\n            token = Object.prototype.toString.call(obj);\n            if (token === '[object Object]') {\n                return (obj.constructor.toString().match(/^function (.*)\\(\\)/m) || [])[1] === 'Object';\n            }\n        }\n        return false;\n    },\n    minMsThreshold = 16,\n    /* istanbul ignore next */win = typeof window === 'undefined' ? (this || {}) : window,\n    // eslint-disable-next-line require-jsdoc\n    /* istanbul ignore next */ reqAnimFrame = (isPrintMode) => {\n        if (isPrintMode) {\n            return function (callback) {\n                setTimeout(callback, minMsThreshold);\n            };\n        }\n        return win.requestAnimationFrame ||\n            win.webkitRequestAnimationFrame ||\n            win.mozRequestAnimationFrame ||\n            win.oRequestAnimationFrame ||\n            win.msRequestAnimationFrame ||\n            function (callback) {\n                setTimeout(callback, minMsThreshold);\n            };\n    },\n\n    getTimeBasedId = () => {\n        if (getTimeBasedId.__lastTime === new Date().getTime()) {\n            return (getTimeBasedId.__lastTime).toString() + (getTimeBasedId.__id++).toString();\n        }\n\n        getTimeBasedId.__id = 0;\n        getTimeBasedId.__lastTime = new Date().getTime();\n        return (getTimeBasedId.__lastTime).toString() + (getTimeBasedId.__id++).toString();\n    },\n    pullableRecent = (nodes, fn) => {\n        let nFn = () => {\n            fn(...nodes.map((node) => {\n                const\n                    hist = node.history,\n                    l = hist.length - 1;\n                return [hist[l - 1 < 0 ? 0 : l - 1], hist[l]];\n            }));\n        };\n        nFn.__id = getTimeBasedId();\n        return nFn;\n    },\n    pullableEnd = (nodes, fn) => {\n        let nFn = () => {\n            fn(...nodes.map((node) => {\n                const hist = node.history;\n                return [hist[0], hist[hist.length - 1]];\n            }));\n        };\n        nFn.__id = getTimeBasedId();\n        return nFn;\n    },\n    unique = fns => fns\n                    .reduce((store, fn) => {\n                // @warn function with side effect, it mutates the store passed during initialization\n                        if (fn.__id in store.map) {\n                            return store;\n                        }\n\n                        store.map[fn.__id] = 1;\n                        store.unique.push(fn);\n\n                        return store;\n                    }, { map: {}, unique: [] })\n                    .unique,\n    compose = fns => () => {\n        fns.forEach(fn => fn());\n    },\n    flat = (params) => {\n        const res = [];\n        params.forEach(param => res.push(...param));\n        return res;\n    },\n    identityMap = arrays => arrays,\n    splitPathProp = (path) => {\n        const pathArr = path.split('.'),\n            len = pathArr.length;\n        return [pathArr.slice(0, len - 1), pathArr[len - 1]];\n    },\n    scheduler = (onFinishCallback, isPrintMode) => {\n        let queue = [],\n            animationFrame = null;\n\n        onFinishCallback = onFinishCallback &&\n            typeof onFinishCallback === 'function' && onFinishCallback || (() => { });\n\n        return (listeners, payload) => {\n            [].push.apply(queue, listeners);\n            if (animationFrame === null) {\n                animationFrame = reqAnimFrame(isPrintMode)(() => {\n                    const tempQ = queue.slice(0);\n                    queue.length = 0;\n                    animationFrame = null;\n\n                    unique(tempQ).forEach(fn => fn());\n                    onFinishCallback(payload);\n                });\n            }\n        };\n    },\n    fetch = namedNode => (...params) => params.map((param) => {\n        const node = namedNode[param];\n        return {\n            name: node.name,\n            qualifiedName: node.qualifiedName,\n            value: node.seed\n        };\n    }),\n    fetchAggregator = (...params) => ({\n        dependencies: params.slice(0, params.length - 1),\n        fn: params[params.length - 1]\n    }),\n    getUpstreamNodes = (list) => {\n        let res = [];\n        const map = {};\n        list.forEach(node => map[node.qualifiedName] = -1);\n        function rec (arr) {\n            arr.forEach((node) => {\n                let qname,\n                    placedIndex,\n                    preArr,\n                    postArr;\n                if (!((qname = node.qualifiedName) in map)) {\n                    map[qname] = res.push(node) - 1;\n                } else {\n                    placedIndex = map[qname];\n                    if (placedIndex !== -1 && placedIndex !== res.length - 1) {\n                        // If not the last element, readjust the array so that the later dependency position is saved\n                        preArr = res.slice(0, placedIndex);\n                        postArr = res.slice(placedIndex + 1);\n                        res = preArr.concat(postArr);\n\n                        // reset the index in map\n                        postArr.forEach((elem, i) => map[elem.qualifiedName] = i + preArr.length);\n                        map[qname] = res.push(node) - 1;\n                    }\n                }\n                rec(node.outgoingEdges);\n            });\n        }\n        rec(list);\n        return res;\n    },\n    resolver = {\n        accumulate: (...params) => {\n            const resp = {};\n            params.forEach((nodeDetails) => {\n                Object.assign(resp, { [nodeDetails.name]: nodeDetails.value });\n            });\n            return resp;\n        },\n        identity: nodeDetails => nodeDetails.value\n    };\n\nfunction resolveDependencyOrder (node, resolved, resolveMap) {\n    let qname;\n    node.edges.forEach((neighbour) => {\n        resolveDependencyOrder(neighbour, resolved, resolveMap);\n    });\n\n    if (node.isRoot() || (qname = node.qualifiedName) in resolveMap) {\n        return;\n    }\n    resolved.push(node);\n    resolveMap[qname] = 1;\n}\n\nfunction shallowMerge(target, ...varArgs) {\n    if (target == null) { // TypeError if undefined or null\n        throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    let to = Object(target);\n\n    for (let index = 0; index < varArgs.length; index++) {\n        let nextSource = varArgs[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n            for (let nextKey in nextSource) {\n                // Avoid bugs when hasOwnProperty is shadowed\n                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                    to[nextKey] = nextSource[nextKey];\n                }\n            }\n        }\n    }\n    return to;\n}\n\nclass CustomResolver {\n    constructor (resolver) {\n        this.fn = resolver;\n        this.dep = [];\n    }\n\n    addDependencies(...dep) {\n        this.dep.push(...dep);\n        return this;\n    }\n\n    getDependencies () {\n        return this.dep;\n    }\n\n    get () {\n        return this.fn;\n    }\n}\n\nexport {\n    shallowMerge,\n    isSimpleObject,\n    scheduler,\n    compose,\n    flat,\n    identityMap,\n    pullableEnd,\n    pullableRecent,\n    unique,\n    splitPathProp,\n    resolver,\n    ForeignSet,\n    resolveDependencyOrder,\n    fetch,\n    fetchAggregator,\n    CustomResolver,\n    getUpstreamNodes\n};\n","export default class GraphNode {\n    constructor (name, qualifiedName, options) {\n        /* istanbul ignore next */options = options || {};\n        this.name = name;\n        this.qualifiedName = qualifiedName;\n        this.edges = [];\n        this.outgoingEdges = [];\n        this._seed = null;\n        this.requireResolve = true;\n        this.retriever = options.retriever;\n        this.history = [];\n        this.resolver = null;\n        this.electricEdges = [];\n    }\n\n    addDependencies (...dep) {\n        this.edges.push(...dep);\n        dep.forEach(entry => entry.outgoingEdges.push(this));\n        return this;\n    }\n\n    addElectricNode (node) {\n        this.electricEdges.push(node);\n        return this;\n    }\n\n    get seed () {\n        return this._seed;\n    }\n\n    set seed (value) {\n        this._seed = value;\n        this.requireResolve = true;\n        return this;\n    }\n\n    resolve () {\n        this.seed = this.resolver(...this.retrieveDetails());\n        this.history.push(this.seed);\n        this.requireResolve = false;\n        return this;\n    }\n\n    retrieveDetails () {\n        if (this.edges.length === 0) {\n            return [{\n                name: this.name,\n                qualifiedName: this.qualifiedName,\n                value: this.seed\n            }];\n        }\n        return this.retriever(...this.edges.map(edge => edge.qualifiedName));\n    }\n\n    repeatHead () {\n        const\n            history = this.history,\n            head = history[history.length - 1];\n        // @todo- Akash, write test case if history.length === 0 to pass code coverage\n        if (history.length === 0) {\n            return this;\n        }\n        history.push(head);\n        return this;\n    }\n\n    flush () {\n        const hist = this.history,\n            head = hist[hist.length - 1];\n        hist.length = 0;\n        hist.push(head);\n        return this;\n    }\n\n    isRoot () {\n        return this.name === null;\n    }\n}\n","import {\n    pullableRecent,\n    pullableEnd\n} from './utils';\n\nexport default class ElectricNode {\n    constructor () {\n        this.edges = [];\n        this.listeners = {\n            nextFrame: [],\n            currentFrame: []\n        };\n    }\n\n    addEdges (...nodes) {\n        this.edges.push(...nodes);\n        return this;\n    }\n\n    regListenerForCurrFrame (fn) {\n        const lstnrs = this.listeners.currentFrame;\n        let index = lstnrs.push(pullableRecent(this.edges, fn)) - 1;\n\n        return () => {\n            this.listeners.currentFrame = lstnrs.filter((fn, i) => i !== index);\n        };\n    }\n\n    regListenerForNextFrame (fn) {\n        const lstnrs = this.listeners.nextFrame;\n        let index = lstnrs.push(pullableEnd(this.edges, fn)) - 1;\n\n        return () => {\n            this.listeners.nextFrame = lstnrs.filter((fn, i) => i !== index);\n        };\n    }\n\n    hasNextFrameListener () {\n        return !!this.listeners.nextFrame.length;\n    }\n}\n","import {\n    isSimpleObject,\n    resolver,\n    // upstreamNodes,\n    flat,\n    resolveDependencyOrder,\n    getUpstreamNodes,\n    ForeignSet,\n    fetch,\n    CustomResolver,\n    scheduler,\n    shallowMerge\n} from './utils';\nimport Node from './graph-node';\nimport ElectricNode from './electric-node';\n\nexport default class Graph {\n    constructor (options) {\n        options = shallowMerge({}, { isPrintMode: false }, options);\n        this.qualifiedNodeMap = {};\n        this.retriever = fetch(this.qualifiedNodeMap);\n        this.root = new Node(null, null, { retriever: this.retriever });\n        this.root.resolver = resolver.accumulate;\n\n        this._wholeSet = null;\n        this._propagate = true;\n        this.propagationOverride = {\n            currentFrameListeners: false,\n            nextFrameListeners: false\n        };\n\n        this._schedule = scheduler((payload) => {\n            let qname;\n            for (qname in payload.flushTarget) {\n                if (!({}).hasOwnProperty.call(this.qualifiedNodeMap, qname)) {\n                    return;\n                }\n                this.qualifiedNodeMap[qname].flush();\n            }\n        }, options.isPrintMode);\n    }\n\n    createNodesFrom (obj, mount) {\n        let val,\n            resolveReqList;\n        const qualifiedNodeMap = this.qualifiedNodeMap,\n            root = this.root,\n            retriever = this.retriever;\n\n        (function rec (objn, qualifiedName, history) {\n            let key,\n                qname,\n                perv,\n                node;\n\n            for (key in objn) {\n                if (!({}).hasOwnProperty.call(objn, key)) {\n                    continue;\n                }\n                qname = `${qualifiedName}${key}`;\n                node = new Node(key, qname, { retriever });\n                qualifiedNodeMap[qname] = node;\n\n                if ((perv = history.perv) !== undefined) {\n                    perv.addDependencies(node);\n                } else {\n                    // top most level entries\n                    root.addDependencies(node);\n                }\n\n                if (isSimpleObject(val = objn[key])) {\n                    rec(val, `${qualifiedName}${key}.`, { perv: node });\n                    node.resolver = resolver.accumulate;\n                } else if (val instanceof CustomResolver) {\n                    node.resolver = val.get();\n                    node.addDependencies(...val.getDependencies().map(qname => qualifiedNodeMap[qname]));\n                } else {\n                    node.resolver = resolver.identity;\n                    node.seed = val;\n                    // node.resolve();\n                }\n            }\n        }(obj, mount === null ? '' : `${mount}.`, {\n            perv: qualifiedNodeMap[mount]\n        }));\n\n        this._wholeSet = new ForeignSet(Object.keys(this.qualifiedNodeMap));\n\n        // Recalculate the model without firing the listeners\n        // @todo selective branch resolve. Currently resolve gets called even for a branch which was updated\n        resolveReqList = this.constructor.getResolvedList(root).concat(root).filter(node => node.requireResolve);\n        resolveReqList.forEach(node => node.resolve());\n        getUpstreamNodes(resolveReqList).forEach(node => node.resolve());\n        return this;\n    }\n\n    getNodeValue (prop) {\n        if (prop in this.qualifiedNodeMap) {\n            return this.qualifiedNodeMap[prop].seed;\n        }\n        return undefined;\n    }\n\n    createElectricNodeOf (props, fnSpec) {\n        const nodes = props.map(prop => this.qualifiedNodeMap[prop]),\n            eNode = new ElectricNode().addEdges(...nodes);\n\n        nodes.forEach(node => node.addElectricNode(eNode));\n        return eNode[`regListenerFor${fnSpec.type}`](fnSpec.fn);\n    }\n\n    update (params) {\n        let changedSet,\n            upstreamNodes;\n        const\n            electricEdges = [],\n            nodes = params.map((entry) => {\n                entry[0].seed = entry[1];\n                return entry[0];\n            });\n        nodes.forEach(node => node.resolve());\n        for (let val of flat(nodes.map(node => node.electricEdges))) {\n            electricEdges.push(val);\n        }\n        changedSet = new ForeignSet(nodes.map(node => node.qualifiedName));\n\n        if (!this._propagate) {\n            this.__execUniqueElectricEdges(electricEdges);\n            this._propagate = true;\n            return this;\n        }\n\n        upstreamNodes = getUpstreamNodes(nodes);\n        upstreamNodes.forEach(upstreamNode => upstreamNode.resolve());\n        changedSet.append(upstreamNodes.map(node => node.qualifiedName));\n        for (let val of flat(upstreamNodes.map(node => node.electricEdges))) {\n            electricEdges.push(val);\n        }\n\n        this.__execUniqueElectricEdges(Array.from(new Set(electricEdges)), changedSet);\n        return this;\n    }\n\n    __execUniqueElectricEdges (electricEdges, changedSet) {\n        const\n            cfLstnrs = [], // current frame listeners\n            nfLstnrs = []; // next frame listeners\n        if (changedSet) {\n            const\n                differenceSet = ForeignSet.difference(this._wholeSet, changedSet),\n                entries = differenceSet.toArray();\n\n            entries.forEach(entry => this.qualifiedNodeMap[entry].repeatHead());\n        }\n\n        electricEdges.forEach((e) => {\n            cfLstnrs.push(...e.listeners.currentFrame);\n        });\n        electricEdges.forEach((e) => {\n            nfLstnrs.push(...e.listeners.nextFrame);\n        });\n\n        !this.propagationOverride.currentFrameListeners && cfLstnrs.forEach(fn => fn());\n        !this.propagationOverride.nextFrameListeners && this._schedule(nfLstnrs, { flushTarget: changedSet });\n        this.resetPropagationOverride();\n        return this;\n    }\n\n    resetNodeValue (...qnames) {\n        const nodes = qnames.map(qname => this.qualifiedNodeMap[qname]),\n            args = nodes.map(node => [node, node.seed]);\n        this.update(args);\n        return this;\n    }\n\n    static getResolvedList (node) {\n        const resolved = [];\n        resolveDependencyOrder(node, resolved, {});\n        return resolved;\n    }\n\n    stopPropagation () {\n        this._propagate = false;\n        return this;\n    }\n\n    resetPropagationOverride () {\n        this.propagationOverride.currentFrameListeners = false;\n        this.propagationOverride.nextFrameListeners = false;\n        return this;\n    }\n\n    setPropagationOverride (key) {\n        this.propagationOverride[`${key}Listeners`] = true;\n        return this;\n    }\n\n    getNodeFromQualifiedName (qname) {\n        return this.qualifiedNodeMap[qname];\n    }\n}\n","import Graph from './graph';\nimport { CustomResolver, fetchAggregator, shallowMerge } from './utils';\n\n/**\n * The container class for Hyperdis. Hyperdis is an enabler for observable object with few interesting features like,\n * calculated property, next frame and same frame listeners, multiple listeners etc with a dependency resolving system.\n * It internally uses a graph to hold the hierarchial relationship of a object. Model is merely a container which\n * ties all the components together.\n *\n * @todo Circular dependency detection is not present\n *\n * @example check src/index.spec.js\n * @class\n */\n\nclass Model {\n    // eslint-disable-next-line require-jsdoc\n    constructor (options) {\n        options = shallowMerge({}, { isPrintMode: false }, options);\n        this._graph = new Graph(options);\n        this._lockFlag = false;\n        this._reqQ = [];\n    }\n\n    /**\n     * Static method to create and init the model with an observable seed\n     *\n     * @param {Object} obj The target object which is required to be made observable\n     * @return {Model} instance of the observable object model\n     */\n    static create (obj, options) {\n        return new Model(options)._addPropInModel(null, obj);\n    }\n\n    /**\n     * Appends more observable property on the already observable instance. This mutates the original model.\n     *\n     * This function works in two mode. One being\n     * @param {String} mountPoint the property on which the new set of properties will be mounted. If its a nested\n     *                          property then the mountPoint has to be written such a way so it feels like you are\n     *                          accessing the object. If the mount point is not found then he obeservables are added in\n     *                          the root.\n     * @param {Object} The target object which is required to be made observable\n     *\n     * Another being\n     * @param {Object} The target object which is required to be made observable\n     *\n     * @return {Model} instance of the observable object model\n     */\n    append (...params) {\n        let mountPoint,\n            obj;\n\n        if (params.length === 1) {\n            mountPoint = null;\n            obj = params[0];\n        } else {\n            mountPoint = params[0];\n            obj = params[1];\n        }\n\n        this._addPropInModel(mountPoint, obj);\n        return this;\n    }\n\n    /**\n     * Creates a calculated variable from existing variable. This variable can't be updated from outside.\n     * @param {string} mountpoint property path on which the new variable will be placed\n     * @param {string} name name of the variable. If the variable could have hierarchy like `limits.start`\n     * @param {Function} fn funtion where the dependent variables are injected based on the dependency requirement\n     */\n    calculatedProp (...params) {\n        let calculationConfig,\n            customResolver,\n            varName,\n            mount,\n            fetchFn;\n\n        if (params.length > 2) {\n            mount = params[0];\n            varName = params[1];\n            fetchFn = params[2];\n        } else {\n            mount = null;\n            varName = params[0];\n            fetchFn = params[1];\n        }\n\n        calculationConfig = fetchFn(fetchAggregator);\n        customResolver = new CustomResolver(calculationConfig.fn);\n        customResolver.addDependencies(...calculationConfig.dependencies);\n\n        this._addPropInModel(mount, { [varName]: customResolver });\n        return this;\n    }\n\n    // eslint-disable-next-line require-jsdoc\n    _addPropInModel (mountPoint, obj) {\n        this._graph.createNodesFrom(obj, mountPoint);\n        return this;\n    }\n\n    /**\n     * Register a listener in the current frame when a property or group of properties is changed.\n     *\n     * @example\n     * This function takes a single or group of property and handler which is called when any of the properties are\n     * changed.\n     * When a single property is changed the handler is called with two parameter, what was the old value of the state\n     * property and what is the new value.\n     * myState.on('range.start', (oldValue, newValue) => {\n     *      console.log('Value before prop change', oldValue);\n     *      console.log('Value after prop change', newValue);\n     * });\n     *\n     * myState.prop('range.start', 9);\n     * // Output\n     * Value before prop change 1\n     * Value after prop change 9\n     *\n     * If a handler is registered on change of a property which has another state property as value, then the handler\n     * gets called whenever any state property connected to it gets changed\n     *\n     * myState.on('range', (oldValue, newValue) => {\n     *      console.log('Value before prop change', oldValue);\n     *      console.log('Value after prop change', newValue);\n     * });\n     *\n     * myState.prop('range.start', 10);\n     * myState.prop('range.type.absolute', false);\n     *\n     * // Output\n     * Value before prop change\n     * range {\n     *      start: 9,\n     *      end: 5,\n     *      type: {\n     *          absolute: true\n     *      }\n     * }\n     * Value after prop change\n     * range: {\n     *      start: 10,\n     *      end: 5,\n     *      type: {\n     *          absolute: false\n     *      }\n     * }\n     * If a handler is registered with more than one property change then, the handler is called when any of the\n     * properties gets changed. In this cast the handler is called with more than one parameter: each for one state\n     * property which is registered for listening. Each parameter is of type array containing [oldValue, newValue]\n     *\n     * myState.on('range.start', 'range.end', (start, end) => {\n     *      console.log('Start', start);\n     *      console.log('End', end);\n     * });\n     *\n     * myState.prop('range.start', 12);\n     *\n     * // Output\n     * Start [10, 12]\n     * End [5, 5]\n     *\n     * myState.prop('range.end', 7);\n     *\n     * // Output\n     * Start [12, 12]\n     * End [5, 7]\n     *\n     * The on returns a function which is when called the listener registered gets unregistered\n     *\n     * let unsub = myState.on(['range.start', 'range.end'], (start, end) => {\n     *      console.log('Start', start);\n     *      console.log('End', end);\n     * });\n     *\n     * // Unsubscribe\n     * unsub()\n     *\n     * On takes an optional boolean value as the last parameter, which if passed as a true value the handler gets called\n     * during registration itself.\n     *\n     * @param {Array.<String>} props List of properties which is of interest\n     * @param {Function} fn Listener to be executed when any of them is changed. The listener is called with the old\n     *                      value and new value of the properties\n     * @param {*} instantCall When registered if the function is to be triggered with the value of the property\n     *\n     * @return {Function} function to unsubscribe from the listeners registry\n     */\n    on (props, fn, instantCall) {\n        const\n            propsArr = props instanceof Array ? props : [props],\n            // All there listeners will be executed in the current stack frame\n            unsub = this._graph.createElectricNodeOf(propsArr, {\n                type: 'CurrFrame',\n                fn\n            });\n\n        if (instantCall) {\n            // Bar current next frame listeners from getting fired\n            this._graph.stopPropagation().setPropagationOverride('nextFrame').resetNodeValue(...props);\n        }\n        return unsub;\n    }\n\n    /**\n     * Register a listener for the next frame when a property or group of properties is changed.\n     *\n     * @example\n     * See the examples for the on listener\n     *\n     * @param {Array.<String>} props List of properties which is of interest\n     * @param {Function} fn Listener to be executed when any of them is changed. The listener is called with the old\n     *                      value and new value of the properties. Here the oldvalue is last value of the last frame\n     * @param {*} instantCall When registered if the function is to be triggered with the value of the property\n     *\n     * @return {Function} function to unsubscribe from the listeners registry\n     */\n    next (props, fn, instantCall) {\n        const\n            propsArr = props instanceof Array ? props : [props],\n            // All there listeners will be executed at the tick of next animation frame\n            unsub = this._graph.createElectricNodeOf(propsArr, {\n                type: 'NextFrame',\n                fn\n            });\n\n        // @todo check support for this from the graph side\n        if (instantCall) {\n            // Bar current frame listeners from getting fired\n            this._graph.stopPropagation().setPropagationOverride('currentFrame').resetNodeValue(...props);\n        }\n\n        return unsub;\n    }\n\n    /**\n     * Lock queues the request of property change and releases the change when unlock is called. This is helpful when\n     * multiple property is getting called and the model listeners are to be fired once at the end of update.\n     *\n     * @return {Model} instance of the model\n     */\n    lock () {\n        this._lockFlag = true;\n        this._reqQ.length = 0;\n        return this;\n    }\n\n    /**\n     * Unlock unleashes the change done after the lock was called.\n\n     * @return {Model} instance of the model\n     */\n    unlock () {\n        this._lockFlag = false;\n        this.setProp(this._reqQ);\n        this._reqQ.length = 0;\n        return this;\n    }\n\n    /**\n     * This acts as getter and setter. If the function is called by passing only one argument, it retrieve the value\n     * associated with the property. If the same function is called using two parameters, first one being the property\n     * and second one being the value, then the value is set for the property and the handlers are called (if any)\n     * which got registered using the on function\n     *\n     * Getter\n     * @param {string} prop property path whose value to be retrieved\n     * @return {Object} value of the property at the time of call\n     *\n     * Setter\n     * @param {string} property property path whose value to be ser\n     * @return {Model} instance of the model\n     */\n    prop (...params) {\n        let prop,\n            val,\n            len;\n\n        switch (len = params.length) {\n        case 1:\n            prop = params[0];\n            break;\n\n        case 2:\n            prop = params[0];\n            val = params[1];\n            break;\n\n        default:\n            return this;\n        }\n\n        if (len === 2) {\n            this._lockFlag ? this._reqQ.push([prop, val]) : this.setProp([[prop, val]]);\n            return this;\n        }\n\n        return this._graph.getNodeValue(prop);\n    }\n\n    // eslint-disable-next-line require-jsdoc\n    setProp (props) {\n        // Filter out the calculated variables, so that it cant be changed from outside\n        // @todo if a node is not leafValue, and change is called, ignore it too\n        // props = props.filter(prop => !(VirtualObj.walkTill(prop[0].split('.'), this._vObj).leafValue()\n        //     instanceof CalculatedVar));\n\n        if (props.length === 0) {\n            return this;\n        }\n\n        this._graph.update(props.map(prop => [this._graph.getNodeFromQualifiedName(prop[0]), prop[1]]));\n        return this;\n    }\n\n    /**\n     * Retrieves the graph representation of the object\n     * @return {Graph} instance of the graph associated to the model\n     */\n    graph () {\n        return this._graph;\n    }\n\n    /**\n     * Get serialized data from the model\n     *\n     * @return {Object} Serialized data\n     */\n    serialize () {\n        return this._graph.root.seed;\n    }\n}\n\nexport default Model;\n","import Model from './model';\n\nexport default Model;\n"],"sourceRoot":""}